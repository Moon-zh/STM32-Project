#include"ZoneCtrl.h"
#include"Rs485.h"
#include"includes.h"
#include "delay.h"
#include "UserCore.h"

ZoneCommand ZoneCtrl;
IOCtrlPara ZonePara;
u8 ZoneSendBuf[10];
u32 IOState;
/*16位CRC校验表*/
const u8 auchCRCHi[]={
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,

0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40
};
const u8 auchCRCLo[]={
0x00,0xc0,0xc1,0x01,0xc3,0x03,0x02,0xc2,0xc6,0x06,0x07,0xc7,0x05,0xc5,0xc4,0x04,
0xcc,0x0c,0x0d,0xcd,0x0f,0xcf,0xce,0x0e,0x0a,0xca,0xcb,0x0b,0xc9,0x09,0x08,0xc8,
0xd8,0x18,0x19,0xd9,0x1b,0xdb,0xda,0x1a,0x1e,0xde,0xdf,0x1f,0xdd,0x1d,0x1c,0xdc,
0x14,0xd4,0xd5,0x15,0xd7,0x17,0x16,0xd6,0xd2,0x12,0x13,0xd3,0x11,0xd1,0xd0,0x10,
0xf0,0x30,0x31,0xf1,0x33,0xf3,0xf2,0x32,0x36,0xf6,0xf7,0x37,0xf5,0x35,0x34,0xf4,
0x3c,0xfc,0xfd,0x3d,0xff,0x3f,0x3e,0xfe,0xfa,0x3a,0x3b,0xfb,0x39,0xf9,0xf8,0x38,
0x28,0xe8,0xe9,0x29,0xeb,0x2b,0x2a,0xea,0xee,0x2e,0x2f,0xef,0x2d,0xed,0xec,0x2c,
0xe4,0x24,0x25,0xe5,0x27,0xe7,0xe6,0x26,0x22,0xe2,0xe3,0x23,0xe1,0x21,0x20,0xe0,

0xa0,0x60,0x61,0xa1,0x63,0xa3,0xa2,0x62,0x66,0xa6,0xa7,0x67,0xa5,0x65,0x64,0xa4,
0x6c,0xac,0xad,0x6d,0xaf,0x6f,0x6e,0xae,0xaa,0x6a,0x6b,0xab,0x69,0xa9,0xa8,0x68,
0x78,0xb8,0xb9,0x79,0xbb,0x7b,0x7a,0xba,0xbe,0x7e,0x7f,0xbf,0x7d,0xbd,0xbc,0x7c,
0xb4,0x74,0x75,0xb5,0x77,0xb7,0xb6,0x76,0x72,0xb2,0xb3,0x73,0xb1,0x71,0x70,0xb0,
0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
0x9c,0x5c,0x5d,0x9d,0x5f,0x9f,0x9e,0x5e,0x5a,0x9a,0x9b,0x5b,0x99,0x59,0x58,0x98,
0x88,0x48,0x49,0x89,0x4b,0x8b,0x8a,0x4a,0x4e,0x8e,0x8f,0x4f,0x8d,0x4d,0x4c,0x8c,
0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
};

u16 CRC16(u8* puchMsg, u16 usDataLen)
{
	u8 uchCRCHi=0xff;
	u8 uchCRCLo=0xff;
	u8 uIndex;
	
	while(usDataLen--)
	{
		uIndex=uchCRCHi^*(puchMsg++);
		uchCRCHi=uchCRCLo^auchCRCHi[uIndex];
		uchCRCLo=auchCRCLo[uIndex];
	}
	return uchCRCHi<<8|uchCRCLo;
}

//清除发送buf
void ZoneBufClear(void)
{
	u8 Cnt = 0;
	for(Cnt=0;Cnt<sizeof(ZoneSendBuf);Cnt++)
	{
		ZoneSendBuf[Cnt++] = 0;
	}
}
void SetIOstate(u8 Num)
{
		IOState = IOState|(1<<(Num-1));
}
//初始化ZoneCtrl
void ZoneCtrl_Init(void)
{
	ZoneCtrl.Enable = 0;
	ZoneCtrl.CtrlNum = 0;
	ZoneCtrl.CtrlType = 0;
}
//分区电磁阀的设置
u8 ZoneCtrl_Set(u8 Type,u8 Num)
{
	if(ZoneCtrl.Enable == 1)
	{
		return 0;
	}
	ZoneCtrl.Enable = 1;
	ZoneCtrl.CtrlNum = Num;
	ZoneCtrl.CtrlType = Type;
	return 1;
}
//初始化ZonePara
void ZonePara_Init(void)
{
	ZonePara.IdleSta = 0;
	ZonePara.RWSta = 0;
	ZonePara.Error = 0;
	
}
//读取模块输入
u8 XRead_Handl(u8*Buf)
{
	Buf[1] = 0x02;
	Buf[2] = 0x00;
	Buf[3] = 0x20;
	Buf[4] = 0x00;
	Buf[5] = 0x04;
	return 6;
}
//读取模块输出
u8 YRead_Handl(u8*Buf)
{
	Buf[1] = 0x01;
	Buf[2] = 0x00;
	Buf[3] = 0x10;
	Buf[4] = 0x00;
	Buf[5] = 0x04;
	return 6;
}
//设置一路输出，同一模块互斥
u8 YSet_Handl(u8*Buf, u8 CircuitNo)
{
	Buf[1] = 0x0F;
	Buf[2] = 0x00;
	Buf[3] = 0x10;
	Buf[4] = 0x00;
	Buf[5] = 0x04;
	Buf[6] = 0x01;
	Buf[7] = (1<<CircuitNo)&0xFF;//需要与硬件对应起来
	return 8;
}
//清除模块输出
u8 YClear_Handl(u8*Buf)
{
	Buf[1] = 0x0F;
	Buf[2] = 0x00;
	Buf[3] = 0x10;
	Buf[4] = 0x00;
	Buf[5] = 0x04;
	Buf[6] = 0x01;
	Buf[7] = 0;
	return 8;
}
u8 YSetMul_Handl(u8*Buf, u8 ConduitF)
{
	Buf[0] = 0x01;
	Buf[1] = 0x0F;
	Buf[2] = 0x00;
	Buf[3] = 0x10;
	Buf[4] = 0x00;
	Buf[5] = 0x04;
	Buf[6] = 0x01;
	Buf[7] = ConduitF;
	return 8;
}
void Frame_Send(u8 CmdType , u8 CmdNum ,u8*Buf)
{
	u8 Cnt = 0;
	u16 Crc= 0;
	OS_CPU_SR  cpu_sr;
	
	//判断该控制哪个io模块//适用于分区电磁阀
	if(CmdNum%4==0)
	{
		Buf[0] = CmdNum/4+1;
	}
	else 
	{
		Buf[0] = CmdNum/4+2;
	}
	//根据命令类型填充所要发送指令
	switch(CmdType)
	{
		case XREAD://读输入
			Cnt = XRead_Handl(Buf);
			break;
		case YREAD://读输出
			Cnt = YRead_Handl(Buf);
			break;
		case YSETSINGLE://设置某一路OUT输出，同一模块的输出互斥
			Cnt = YSet_Handl(Buf , (CmdNum-1)%4);
			break;
		case YCLEAR://清除某一模块全部输出
			Cnt = YClear_Handl(Buf);
			break;
		case YSETMUL://通道电磁阀设置
			Cnt = YSetMul_Handl(Buf, CmdNum);
			break;
		default:
			break;
	}
	
	OS_ENTER_CRITICAL();
	Crc = CRC16(Buf , Cnt);
	OS_EXIT_CRITICAL();
	Buf[Cnt++] = (u8)((Crc>>8)&0xff);
	Buf[Cnt++] = (u8)(Crc&0xff);
	comSendBuf(COM4,Buf,Cnt);
	ZonePara.RWSta = READSTA;//已经发送完毕，转换为读取状态
	
}
//解析输出状态
u8 Unfreame_YSta(u8* ReceiveBuf)
{
	if(ReceiveBuf[3] > 0x0f )
	{
		return 0;
	}
	IOState = (ReceiveBuf[3]<<((ReceiveBuf[0]-2)*4)) 
				& (IOState|(0x0F<<((ReceiveBuf[0]-2)*4)));
	return 1;
}
//解析收到的报文
u8 Unfreame_Recive(u8* Buf)
{
	OS_CPU_SR  cpu_sr;
	u8 ReBuf[15] = {0};
	u16 Crc;
	u8 ReValue = 0;
	u8 BufLen = 0;
	//是否收到数据判断
//	BufLen = COM4GetBuf(ReBuf);
	if(BufLen == 0)
	{
		return 0;
	}
	//地址判断
	if(Buf[0] != ReBuf[0])
	{
		return 0;
	}
	//CRC判断
	Crc = ReBuf[BufLen - 2]<<8|ReBuf[BufLen - 1];
	
	OS_ENTER_CRITICAL();
	if(Crc != CRC16(ReBuf, BufLen - 2))
	{
		return 0;
	}
	OS_EXIT_CRITICAL();
	//分析报文
	switch(ReBuf[1])
	{
		case 0x01://输出状态解析
			ReValue = Unfreame_YSta(ReBuf);
			break;
		case 0x02://输入状态解析
			//用不到暂时先空着
			break;
		case 0x0f://控制解析
			ReValue =1;//地址与控制字对就任务命令执行成功
			break;
		default:
			break;
	}
	return ReValue;	
}
void CmdComletion(u8 MsgType,u8 Addr, u8 Flag)
{
	OS_CPU_SR  cpu_sr;
	
	MsgStruct Msgtemp;
	Msgtemp.CmdType = MsgType;
	Msgtemp.CmdSrc = ZONE_TASK_CODE;
	Msgtemp.CmdData[0] = Addr;
	Msgtemp.CmdData[1] = Flag;
	OS_ENTER_CRITICAL();
	PackSendMasterQ(&Msgtemp);
	OS_EXIT_CRITICAL();
}
//分区控制任务
// alfred
// 添加局部变量更新消息判断数据读取与控制
void ZoneCtrl_task(void *pdata)
{
	ZoneCtrl_Init();
	ZonePara_Init();
	ZoneBufClear();
	while(1)
	{
		delay_ms(50);//需要测试多久合适 alfred to be continue
		//分区空闲
		if(ZonePara.IdleSta == 0)
		{
			if(ZoneCtrl.Enable == 1)
			{
				ZonePara.RWSta = WRITESTA;
				ZonePara.IdleSta = 1;
			}
		}
		else if(ZonePara.IdleSta == 1)//分区忙
		{
			switch(ZonePara.RWSta)
			{
				case READSTA:
					if(Unfreame_Recive(ZoneSendBuf))//解析收到的报文
					{
//						CmdComletion(MSG_ZONEALARM,ZoneSendBuf[0],0);
						ZoneBufClear();
						ZoneCtrl_Init();
						ZonePara_Init();
					}
					else 
					{
						if(ZonePara.Error++ > 5)
						{
							if(ZonePara.Error > 10)//重发一次收不到数据认为模块掉线
							{
//								CmdComletion(MSG_ZONEALARM,ZoneSendBuf[0],1);
								ZoneBufClear();
								ZoneCtrl_Init();
								ZonePara_Init();
							}
							else if(ZonePara.Error == 5)
							{
								ZonePara.RWSta = 0x02;//5次收不到数据重发一次
							}
						}
					}
					break;
				case WRITESTA:
					Frame_Send(ZoneCtrl.CtrlType,ZoneCtrl.CtrlNum, ZoneSendBuf);//组帧发送
					break;
				default://收到错误数据初始化所有
					ZoneBufClear();
					ZoneCtrl_Init();
					ZonePara_Init();
					break;
			}
		}
		
	}
}
