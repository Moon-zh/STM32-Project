#include "ZoneCtrl.h"
#include "Rs485.h"
#include "includes.h"
#include "delay.h"
#include "UserCore.h"
#include "UserHmi.h"

IOCtrlPara ZonePara;
ZoneCommand SlaveCtrl;
SlaveStateStruct SlaveState;
#define SlAVEID 1
/*16位CRC校验表*/
const u8 auchCRCHi[]={
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,

0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40
};
const u8 auchCRCLo[]={
0x00,0xc0,0xc1,0x01,0xc3,0x03,0x02,0xc2,0xc6,0x06,0x07,0xc7,0x05,0xc5,0xc4,0x04,
0xcc,0x0c,0x0d,0xcd,0x0f,0xcf,0xce,0x0e,0x0a,0xca,0xcb,0x0b,0xc9,0x09,0x08,0xc8,
0xd8,0x18,0x19,0xd9,0x1b,0xdb,0xda,0x1a,0x1e,0xde,0xdf,0x1f,0xdd,0x1d,0x1c,0xdc,
0x14,0xd4,0xd5,0x15,0xd7,0x17,0x16,0xd6,0xd2,0x12,0x13,0xd3,0x11,0xd1,0xd0,0x10,
0xf0,0x30,0x31,0xf1,0x33,0xf3,0xf2,0x32,0x36,0xf6,0xf7,0x37,0xf5,0x35,0x34,0xf4,
0x3c,0xfc,0xfd,0x3d,0xff,0x3f,0x3e,0xfe,0xfa,0x3a,0x3b,0xfb,0x39,0xf9,0xf8,0x38,
0x28,0xe8,0xe9,0x29,0xeb,0x2b,0x2a,0xea,0xee,0x2e,0x2f,0xef,0x2d,0xed,0xec,0x2c,
0xe4,0x24,0x25,0xe5,0x27,0xe7,0xe6,0x26,0x22,0xe2,0xe3,0x23,0xe1,0x21,0x20,0xe0,

0xa0,0x60,0x61,0xa1,0x63,0xa3,0xa2,0x62,0x66,0xa6,0xa7,0x67,0xa5,0x65,0x64,0xa4,
0x6c,0xac,0xad,0x6d,0xaf,0x6f,0x6e,0xae,0xaa,0x6a,0x6b,0xab,0x69,0xa9,0xa8,0x68,
0x78,0xb8,0xb9,0x79,0xbb,0x7b,0x7a,0xba,0xbe,0x7e,0x7f,0xbf,0x7d,0xbd,0xbc,0x7c,
0xb4,0x74,0x75,0xb5,0x77,0xb7,0xb6,0x76,0x72,0xb2,0xb3,0x73,0xb1,0x71,0x70,0xb0,
0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
0x9c,0x5c,0x5d,0x9d,0x5f,0x9f,0x9e,0x5e,0x5a,0x9a,0x9b,0x5b,0x99,0x59,0x58,0x98,
0x88,0x48,0x49,0x89,0x4b,0x8b,0x8a,0x4a,0x4e,0x8e,0x8f,0x4f,0x8d,0x4d,0x4c,0x8c,
0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
};

u16 CRC16(u8* puchMsg, u16 usDataLen)
{
	u8 uchCRCHi=0xff;
	u8 uchCRCLo=0xff;
	u8 uIndex;
	
	while(usDataLen--)
	{
		uIndex=uchCRCHi^*(puchMsg++);
		uchCRCHi=uchCRCLo^auchCRCHi[uIndex];
		uchCRCLo=auchCRCLo[uIndex];
	}
	return uchCRCHi<<8|uchCRCLo;
}
//分区控制任务
// alfred
// 添加局部变量更新消息判断数据读取与控制
OS_EVENT * ZoneQMsg;
void* 	ZoneMsgBlock[4];
OS_MEM* ZonePartitionPt;
u8 g_u8ZoneMsgMem[20][4];

//创建消息队列和内存块
//输出0：创建正常
//    1：消息队列创建失败
//	  2：内存块创建失败
u8 ZoneQInit(void)
{
	INT8U os_err;
	
	ZoneQMsg = OSQCreate ( ZoneMsgBlock, 4);
	
	if(ZoneQMsg == (OS_EVENT *)0)
	{
		return 1;
	}
	
	ZonePartitionPt = OSMemCreate (
										g_u8ZoneMsgMem,
				  						20,
				  						4,
				  						&os_err 
				  				   );
	if(os_err != OS_ERR_NONE)
	{
		return 2;
	}
	return 0;
	
}
//消息打包发走
//输入：消息信息
//输出：0：发送成功
//		1：申请内存失败
//		2：发送消息失败

u8 PackSendZoneQ(MsgStruct* MsgBlk)
{
	INT8U os_err;
	MsgStruct * MsgTemp = NULL;
	MsgTemp = (MsgStruct *)OSMemGet(ZonePartitionPt,&os_err);
	if(MsgTemp == NULL)
	{
		return 1;
	}
	MsgTemp ->CmdType = MsgBlk->CmdType;
	MsgTemp ->CmdSrc = MsgBlk->CmdSrc;
	MsgTemp ->CmdData[0] = MsgBlk->CmdData[0];
	MsgTemp ->CmdData[1] = MsgBlk->CmdData[1];
	os_err = OSQPost ( ZoneQMsg,(void*)MsgTemp );
	//发送消息失败释放内存
	if(os_err!=OS_ERR_NONE)
	{
		OSMemPut(ZonePartitionPt, ( void * )MsgTemp);
		return 2;
	}
	return 0;
}
//队列消息解析，消息内存释放
//输入：收到的消息队列指针
//输出：0：释放成功
//		1：释放失败
u8 DepackReceiveZoneQ(MsgStruct * MasterQ)
{
	u8 os_err;
	os_err = OSMemPut(ZonePartitionPt, ( void * )MasterQ);
	if(os_err != OS_ERR_NONE)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
SlaveStruct SlavePara;

u8 PackStartCmd(u8* Buf)
{
	u8 Len = 0;
//	WaterProgStruct	WaterProg;
	
	//取浇水程序
	//取用肥量
	//
	Buf[Len++] = 13;
	Buf[Len++] = SlavePara.WaterBefore;
	Buf[Len++] = SlavePara.WaterAfter;//浇水后置时间
	Buf[Len++] = SlavePara.WaterTime;//浇水施肥时间
	Buf[Len++] = SlavePara.DosingQty[0];//1号桶流量
	Buf[Len++] = SlavePara.DosingQty[1];//2号桶流量
	Buf[Len++] = SlavePara.DosingQty[2];//3号桶流量
	Buf[Len++] = SlavePara.DosingQty[3];//4号桶流量
	Buf[Len++] = SlavePara.DosingQty[4];//5号桶流量
	Buf[Len++] = SlavePara.DosingSwitch;//通道阀
	Buf[Len++] = SlavePara.ValveGroup>>24;//灌溉组1
	Buf[Len++] = SlavePara.ValveGroup>>16;//灌溉组2
	Buf[Len++] = SlavePara.ValveGroup>>8;//灌溉组3
	Buf[Len++] = SlavePara.ValveGroup;//灌溉组4
	return (Len+2) ;
}
u8 PackStopCmd(u8* Buf)
{
	u8 Len = 0;
	Buf[Len++] = 2;
	Buf[Len++] = 0;
	Buf[Len++] = 0;
	return (Len+2) ;
}
u8 PackAskCmd(u8* Buf)
{
	u8 Len = 0;
	Buf[Len++] = 2;
	Buf[Len++] = 0;
	Buf[Len++] = 0;
	return (Len+2) ;
}
u8 PackClearCmd(u8* Buf)
{
	u8 Len = 0;
	Buf[Len++] = 2;
	Buf[Len++] = 0;
	Buf[Len++] = 0;
	return (Len+2) ;
}
void SlaveCmdSend(u8 Type)
{
	u8 Buf[16];
	u8 Len = 0;
	Buf[0] = SlAVEID;
	Buf[1] = Type;
	switch(Type)
	{
		case START_CMD://开始命令
			Len = PackStartCmd(&Buf[2]);
			break;
		case STOP_CMD://停止命令
			Len = PackStopCmd(&Buf[2]);
			break;
		case ASK_CMD://查询命令
			Len = PackAskCmd(&Buf[2]);
			break;
		case CLEAR_CMD://清除报警命令
			Len = PackClearCmd(&Buf[2]);
			break;
		default:
			break;
	}
	comSendBuf(COM3,Buf,Len);
}
u8 UnpackAsk(u8* Buf)
{
	u8 u8Cnt = 3;
	SlaveState.State = Buf[u8Cnt++];
	SlaveState.WaterBeforehour = Buf[u8Cnt++];
	SlaveState.WaterBeforemin = Buf[u8Cnt++];
	SlaveState.WaterBeforesec = Buf[u8Cnt++];
	SlaveState.WaterAfterhour = Buf[u8Cnt++];
	SlaveState.WaterAftermin = Buf[u8Cnt++];
	SlaveState.WaterAftersec = Buf[u8Cnt++];
	SlaveState.WaterTimehour = Buf[u8Cnt++];
	SlaveState.WaterTimemin = Buf[u8Cnt++];
	SlaveState.WaterTimesec = Buf[u8Cnt++];
	SlaveState.PumpState = Buf[u8Cnt++];
	SlaveState.DosingSwitch = Buf[u8Cnt++];
	SlaveState.DosingQty[0] = Buf[u8Cnt++];
	SlaveState.DosingQty[1] = Buf[u8Cnt++];
	SlaveState.DosingQty[2] = Buf[u8Cnt++];
	SlaveState.DosingQty[3] = Buf[u8Cnt++];
	SlaveState.DosingQty[4] = Buf[u8Cnt++];
	SlaveState.ValveGroup = (Buf[u8Cnt++]<<24)|(Buf[u8Cnt++]<<16)|(Buf[u8Cnt++]<<8)
							|Buf[u8Cnt++];
	memcpy(&SlaveState.Alarm[0],&Buf[u8Cnt],22);
	
	Hmi_Buf[0] = SlaveState.WaterBeforehour*60+SlaveState.WaterBeforemin;
	Hmi_Buf[1] = SlaveState.WaterAfterhour*60+SlaveState.WaterAftermin;
	Hmi_Buf[2] = SlaveState.WaterTimehour*60+SlaveState.WaterTimemin;
	Hmi_Buf[3] = SlaveState.DosingQty[0];
	Hmi_Buf[4] = SlaveState.DosingQty[1];
	Hmi_Buf[5] = SlaveState.DosingQty[2];
	Hmi_Buf[6] = SlaveState.DosingQty[3];
	Hmi_Buf[7] = SlaveState.DosingQty[4];
	Hmi_Buf[8] = 736;
	Hmi_Buf[9] = 2;
	//WorkStateShow();
	u8Cnt = u8Cnt + 22;
	return u8Cnt;
}
void StopOkCmdSend(void)
{
	MsgStruct  MsgTemp;

	//向主任务发送启动消息
	MsgTemp.CmdSrc = SCREEN_TASK_CODE;
	MsgTemp.CmdType = MSG_CANCLEOK;
	PackSendMasterQ(&MsgTemp);
}
u8 SlaveCmdRev(void)
{
	u8 RevBuf[48];
	u8 RevBufLen=0;
	RevBufLen = COMGetBuf(COM3,RevBuf,48);
	if(RevBufLen<5)
	{
		return 1;
	}
	if(RevBuf[0]!=SlAVEID)
	{
		return 2;
	}
	switch(RevBuf[1])
	{
		case START_CMD:
			if(RevBuf[3] != 0x4f||RevBuf[4]!=0x4b)
			{
				return 3;
			}
			break;
		case STOP_CMD:
			StopOkCmdSend();
			if(RevBuf[3] != 0x4f||RevBuf[4]!=0x4b)
			{
				return 3;
			}
			
			break;
		case CLEAR_CMD:
			if(RevBuf[3] != 0x4f||RevBuf[4]!=0x4b)
			{
				return 3;
			}
			break;
		case ASK_CMD:
			UnpackAsk(&RevBuf[3]);
			break;
		default:
			return 4;
	}
	return 0;
}
void ZoneCtrl_task(void *pdata)
{
	MsgStruct * pMsgBlk = NULL;
	MsgStruct Msgtemp;
	//	MsgStruct ZoneMsg;
	u8 os_err;	
	ZoneQInit();
	while(1)
	{
		delay_ms(100);//需要测试多久合适 alfred to be continue
		//当该任务处于空闲时
		if(ZonePara.TaskSta == 0)
		{
			pMsgBlk = ( MsgStruct *) OSQPend ( ZoneQMsg,
						10,
						&os_err );
			if(os_err == OS_ERR_NONE)
			{
				memcpy((u8*)&Msgtemp,(u8*)pMsgBlk,sizeof(MsgStruct) );
				DepackReceiveZoneQ(pMsgBlk);
				ZonePara.TaskSta = 1;
				ZonePara.Type = Msgtemp.CmdType;
			}
			else
			{
				if(ZonePara.AskCnt++ > 15)
				{	
					ZonePara.AskCnt = 0;
					ZonePara.TaskSta = 1;
					ZonePara.Type = ASK_CMD;
				}
			}
		}
		else
		{
			switch(ZonePara.TaskSta)
			{
				case 1://send 
					SlaveCmdSend(ZonePara.Type);
					ZonePara.TaskSta = 2;
					break;
				case 2://receive
					//解析指令	
					if(SlaveCmdRev()==0)
					{
						ZonePara.ErrCnt = 0;
						ZonePara.TaskSta = 0;
						
					}
					else
					{
						if(ZonePara.ErrCnt++>10)
						{
							ZonePara.ErrCnt = 0;;
							//发送通信异常
							ZonePara.TaskSta = 0;
						}
					}
					break;
				default:
					break;
			}
		}
		
	}
}
